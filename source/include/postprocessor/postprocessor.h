/*
 * This file is part of the SYMPLER package.
 * https://github.com/kauzlari/sympler
 *
 * Copyright 2002-2013, 
 * David Kauzlaric <david.kauzlaric@frias.uni-freiburg.de>,
 * and others authors stated in the AUTHORS file in the top-level 
 * source directory.
 *
 * SYMPLER is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SYMPLER is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SYMPLER.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Please cite the research papers on SYMPLER in your own publications. 
 * Check out the PUBLICATIONS file in the top-level source directory.
 *
 * You are very welcome to contribute extensions to the code. Please do 
 * so by making a pull request on https://github.com/kauzlari/sympler
 * 
 */



#ifndef __POSTPROCESSOR_H
#define __POSTPROCESSOR_H

#include "smart_enum.h"
#include "data_format.h"
#include "node_many_children.h"

class Simulation;

/*!
 * \a Postprocessor s take information generated by \a Meter s and write
 * the to file/stream or perform further operations on the data.
 *
 * Note that \a Postprocessor a can be nested, i.e., the output of one
 * \a Postprocessor can fed into another one.
 */ 
class Postprocessor: public NodeManyChildren
{
 protected:
  /*!
   * Pointer to main simulation object
   */
  Simulation *m_simulation;

  /*!
   * Format description for the output of this \a Postprocessor
   */
  DataFormat m_output;

  /*!
   * Look for child postprocessors
   */
  virtual Node *instantiateChild(const string &name);

  /*!
   * Data collection has finished. Distribute this data to the child 
   * \a Postprocessor s
   */
  inline void distribute(data_sp data) {
    for (list<Node*>::iterator i = m_children.begin(); i != m_children.end(); i++)
      ((Postprocessor*) *i)->push(data);
  }

public:
  /*!
   * Constructor
   * @param parent The parent node, i.e., either a \a Meter or another \a Postprocessor
   * @param simulation Pointer to the main simulation node
   */
  Postprocessor(Node *parent, Simulation *simulation);

  /*!
   * Destructor
   */
  virtual ~Postprocessor();

  /*!
   * Calls NodeManyChildren::setup()
   */
  virtual void setup();

  /*!
   * This is called once to tell the \a Postprocessor which format the data
   * in \a push has.
   * @param input_format Pointer to the format description
   */
  virtual void describeInput(DataFormat *input_format) = 0;

  /*!
   * This function return the type of data the postprocessor will output,
   * or NULL if it doesn't output anything (e.g. writes to a file)
   */
  virtual DataFormat *describeOutput() {
    return &m_output;
  }

  /*!
   * This is called for every data point that is being generated
   */
  virtual void push(data_sp data) = 0;

  /*!
   * This one is called at the end of the simulation. It calls flush for every child.
   */
  virtual void flush();
};



//---- Factories ----

class Postprocessor_Factory: public SmartEnum<Postprocessor_Factory>
{
public:
    virtual Postprocessor *instantiate(Node *node, Simulation *simulation) const = 0;

protected:
    Postprocessor_Factory(const string &name)
    : SmartEnum<Postprocessor_Factory>(name) { }
};


template <class T>
class Postprocessor_Register: public Postprocessor_Factory
{
public:
    Postprocessor_Register(const string &name)
    : Postprocessor_Factory(name) { }

    virtual Postprocessor *instantiate(Node *node, Simulation *simulation) const;
};



//---- Inline functions ----

template <class T>
inline Postprocessor *Postprocessor_Register<T>::instantiate(Node *node, Simulation *simulation) const
{
    return new T(node, simulation);
}



#endif
